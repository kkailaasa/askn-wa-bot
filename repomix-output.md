This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-08 05:50:16

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
.env.example
app
  db
    database.py
    models.py
  scheduler
    tasks.py
    __init__.py
  tasks
    utils.py
  __init__.py
docker-compose.yml
Dockerfile
main.py
main.py.2
README.md
requirements.txt
__init__.py
```

# Repository Files


## .env.example

- Characters: 197
- Tokens: 68

```text
DIFY_BASE_URL=http://your-dify-instance/v1
DIFY_KEY=your-dify-key
TWILIO_ACCOUNT_SID=your-twilio-sid
TWILIO_AUTH_TOKEN=your-twilio-token
TWILIO_NUMBER=your-twilio-number
RATE_LIMIT=3
TIME_WINDOW=60
```

## docker-compose.yml

- Characters: 1592
- Tokens: 464

```yaml
version: '3.8'
services:
  web:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: an_wa_bot
    ports:
      - "8051:8000"
    environment:
      - REDIS_HOST=redis
      - REDIS_PORT=6379
      - DIFY_BASE_URL=${DIFY_BASE_URL}
      - DIFY_KEY=${DIFY_KEY}
      - TWILIO_ACCOUNT_SID=${TWILIO_ACCOUNT_SID}
      - TWILIO_AUTH_TOKEN=${TWILIO_AUTH_TOKEN}
      - TWILIO_NUMBER=${TWILIO_NUMBER}
    depends_on:
      - redis
      - celery_worker
    volumes:
      - ./app_data:/app/app_data
    networks:
      - internal
      - dify_network
    restart: unless-stopped

  redis:
    image: redis:6.2-alpine
    container_name: an_wa_redis
    volumes:
      - ./redis_data:/data
    command: ["redis-server", "--bind", "0.0.0.0", "--protected-mode", "no"]
    networks:
      - internal
    restart: unless-stopped

  celery_worker:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: an_wa_celery_worker
    command: celery -A app.scheduler.tasks worker --loglevel=info
    environment:
      - REDIS_HOST=redis
      - REDIS_PORT=6379
      - DIFY_BASE_URL=${DIFY_BASE_URL}
      - DIFY_KEY=${DIFY_KEY}
      - TWILIO_ACCOUNT_SID=${TWILIO_ACCOUNT_SID}
      - TWILIO_AUTH_TOKEN=${TWILIO_AUTH_TOKEN}
      - TWILIO_NUMBER=${TWILIO_NUMBER}
    depends_on:
      - redis
    volumes:
      - ./app_data:/app/app_data
    networks:
      - internal
      - dify_network
    restart: unless-stopped

networks:
  internal:
    driver: bridge
  dify_network:
    external: true
    name: dify-chandra_default

volumes:
  app_data:
  redis_data:
```

## Dockerfile

- Characters: 735
- Tokens: 197

```text
# Dockerfile
FROM python:3.10-slim

# Set working directory
WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements first to leverage Docker cache
COPY requirements.txt .

# Install Python dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Copy the application code
COPY . .

# Create directory for SQLite database and logs
RUN mkdir -p /app/app_data && \
    chmod 777 /app/app_data

# Add the current directory to PYTHONPATH
ENV PYTHONPATH=/app:${PYTHONPATH}

# Set environment variables
ENV PYTHONUNBUFFERED=1

# Default command
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

## main.py

- Characters: 5884
- Tokens: 1150

```python
from fastapi import FastAPI, Form, HTTPException, Request
from typing import Optional
from app.scheduler.tasks import process_question
from app.db.database import init_db
import logging
from datetime import datetime

# Configure logging with timestamp
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('app_data/app.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

app = FastAPI(title="WhatsApp Bot API")

@app.on_event("startup")
async def startup_event():
    try:
        init_db()
        logger.info("Database initialized successfully")
    except Exception as e:
        logger.error(f"Failed to initialize database: {str(e)}")
        raise

@app.get("/")
async def root():
    return {
        "status": "running",
        "timestamp": datetime.utcnow().isoformat(),
        "version": "1.0.0"
    }

@app.post("/message")
async def reply(request: Request):
    try:
        # Get form data
        form = await request.form()
        
        # Log all incoming data for debugging
        logger.info("Received webhook data:")
        for key, value in form.items():
            logger.info(f"{key}: {value}")

        # Extract fields with defaults
        message_sid = form.get('MessageSid', '')
        body = form.get('Body', '')
        from_number = form.get('From', '')
        to_number = form.get('To', '')
        num_media = form.get('NumMedia', '0')
        message_status = form.get('MessageStatus', '')
        sms_status = form.get('SmsStatus', '')
        message_type = form.get('MessageType', '')

        # Log basic request info
        logger.info(f"Received webhook - MessageSid: {message_sid}, From: {from_number}, To: {to_number}")

        # Handle status updates - only for specific status types
        if message_status in ['sent', 'delivered', 'read', 'failed'] or sms_status in ['sent', 'delivered', 'read', 'failed']:
            status = message_status or sms_status
            logger.info(f"Status update received: {status}")
            return {
                "status": "success",
                "type": "status_update",
                "message": f"Status update ({status}) received"
            }

        # Process incoming messages
        if message_type == 'text' or body or int(num_media) > 0:
            # Validate From number
            if not from_number:
                logger.error("Missing From number")
                return {
                    "status": "error",
                    "message": "Missing From number"
                }

            # Clean the phone number
            from_number = from_number.strip()
            if not from_number.startswith("whatsapp:"):
                from_number = f"whatsapp:{from_number}"

            # Handle media messages
            media_items = []
            if num_media and int(num_media) > 0:
                num_media_int = int(num_media)
                logger.info(f"Media message received - Count: {num_media_int}")

                # Collect all media URLs and types
                for i in range(num_media_int):
                    url = form.get(f'MediaUrl{i}')
                    content_type = form.get(f'MediaContentType{i}')

                    if url and content_type:
                        media_items.append({
                            "url": url,
                            "content_type": content_type,
                            "index": i
                        })
                        logger.info(f"Media {i}: Type: {content_type}, URL: {url}")

                message_text = body if body else "Image message"
                try:
                    process_question.delay(message_text, from_number, media_items)
                    logger.info(f"Task queued successfully for {from_number} with {len(media_items)} media items")
                    return {
                        "status": "success",
                        "message": "Message with media received and queued for processing"
                    }
                except Exception as e:
                    logger.error(f"Failed to queue media task: {str(e)}")
                    raise HTTPException(
                        status_code=500,
                        detail="Failed to process media message"
                    )

            # Handle text-only messages
            elif body:
                logger.info(f"Processing text message - From: {from_number}, Body: {body}")
                
                try:
                    process_question.delay(body, from_number)
                    logger.info(f"Task queued successfully for {from_number}")
                    return {
                        "status": "success",
                        "message": "Message received and queued for processing"
                    }
                except Exception as e:
                    logger.error(f"Failed to queue task: {str(e)}")
                    raise HTTPException(
                        status_code=500,
                        detail="Failed to process message"
                    )

        # Handle other types of webhooks
        logger.warning("Received webhook with no message content")
        return {
            "status": "success",
            "type": "unknown",
            "message": "Webhook received but no message content found"
        }

    except Exception as e:
        logger.error(f"Unexpected error processing webhook: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail="Internal server error"
        )

@app.get("/health")
async def health_check():
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat()
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

## main.py.2

- Characters: 948
- Tokens: 218

```text
from fastapi import FastAPI, Form, HTTPException
from typing import Optional
from app.scheduler.tasks import process_question
from app.db.database import init_db

app = FastAPI()

@app.on_event("startup")
async def startup_event():
    init_db()

@app.post("/message")
async def reply(
    Body: Optional[str] = Form(None),
    From: Optional[str] = Form(None),
):
    # Validate required fields
    if not Body or not From:
        raise HTTPException(
            status_code=422,
            detail="Both 'Body' and 'From' fields are required"
        )

    # Clean the phone number
    From = From.strip()
    if not From.startswith("whatsapp:"):
        From = f"whatsapp:{From}"

    # Log the incoming message
    print(f"Received message from {From}: {Body}")

    # Process the message
    process_question.delay(Body, From)

    # Return a simple acknowledgment
    return {"status": "Message received", "message": "Task added to queue"}
```

## README.md

- Characters: 1300
- Tokens: 322

````markdown
# prerequisites
- python3
- git
- redis
- tmux

Redis-server is used for caching the user login, conversation id, and rate limiting. It is also used by celery as broker.

# commands to run
commands need to run from the project_root_folder
- after cloning the progect create a python venv
- then install all the libraries from requirements.txt
- then run the uvicorn command `uvicorn main:app --host 0.0.0.0 --port 8000`
to run it in detached mode you can use nohup at the begining of the command and & at the end
- then run the celery command `celery -A scheduler.tasks worker --loglevel=info`
to run this in detached mode you can use nohup at the begining of the command and & at the end

## Deploying with Docker

Follow these steps to deploy the application using Docker:

0. Clone the Git repository:
    ```bash
    git clone <repository-url>
    ```

1. Update your `.env` file with the necessary environment variables.

2. Build the Docker image:
    ```bash
    docker build -t an-wa-bot:v1 .
    ```

3. Run Docker Compose:
    ```bash
    docker compose up -d
    ```

4. Check the logs to ensure everything is running correctly:
    ```bash
    docker compose logs -f
    ```

5. Configure your reverse proxy according to your setup.

6. Configure Cloudflare as needed for your deployment.
````

## requirements.txt

- Characters: 91
- Tokens: 28

```text
fastapi
uvicorn
twilio
python-decouple
python-multipart
dify-client
redis
celery
sqlalchemy
```

## __init__.py

- Characters: 0
- Tokens: 0

```python

```

## app\__init__.py

- Characters: 0
- Tokens: 0

```python

```

## app\db\database.py

- Characters: 436
- Tokens: 100

```python
# database.py
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.db.models import Base

DATABASE_URL = "sqlite:///./app_data/chat.db"
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def init_db():
    Base.metadata.create_all(bind=engine)

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

## app\db\models.py

- Characters: 507
- Tokens: 114

```python
# models.py
from sqlalchemy import Column, Integer, String, DateTime, Text
from sqlalchemy.ext.declarative import declarative_base
from datetime import datetime

Base = declarative_base()

class MessageLog(Base):
    __tablename__ = 'message_logs'

    id = Column(Integer, primary_key=True)
    phone_number = Column(String(50))
    message = Column(Text)
    response = Column(Text)
    created_at = Column(DateTime, default=datetime.utcnow)
    status = Column(String(50))  # success, error, rate_limited
```

## app\scheduler\tasks.py

- Characters: 6412
- Tokens: 1343

```python
# tasks.py
from celery import Celery
from dify_client import ChatClient
from decouple import config
from app.tasks.utils import send_message, logger, is_rate_limited, log_message
import requests
from typing import Optional, List, Dict
import tempfile
import os
from twilio.rest import Client

app = Celery('tasks', broker='redis://redis:6379/0', backend='redis://redis:6379/0')
app.conf.update(
    task_serializer='json',
    accept_content=['json'],
    result_serializer='json',
    timezone='UTC',
    enable_utc=True,
)

# Initialize Twilio client
account_sid = config('TWILIO_ACCOUNT_SID')
auth_token = config('TWILIO_AUTH_TOKEN')
twilio_client = Client(account_sid, auth_token)

def get_dify_base_url():
    """Get base URL without trailing slash"""
    base_url = config('DIFY_BASE_URL').rstrip('/')
    if not base_url.endswith('/v1'):
        base_url = f"{base_url}/v1"
    return base_url

def upload_file_to_dify(media_content: bytes, content_type: str, user: str) -> Optional[Dict]:
    """Upload a file to Dify's file storage"""
    try:
        dify_key = config('DIFY_KEY')
        base_url = get_dify_base_url()
        upload_url = f"{base_url}/files/upload"

        # Create temporary file with proper extension
        extension = {
            'image/jpeg': '.jpg',
            'image/png': '.png',
            'image/gif': '.gif',
            'image/webp': '.webp'
        }.get(content_type, '.jpg')

        with tempfile.NamedTemporaryFile(suffix=extension, delete=False) as temp_file:
            temp_file.write(media_content)
            temp_file_path = temp_file.name

        try:
            with open(temp_file_path, 'rb') as f:
                files = {'file': (f'image{extension}', f, content_type)}
                headers = {'Authorization': f'Bearer {dify_key}'}
                data = {'user': user}

                logger.info(f"Uploading file to Dify: {upload_url}")
                upload_response = requests.post(
                    upload_url,
                    headers=headers,
                    files=files,
                    data=data
                )
                upload_response.raise_for_status()

                # Log response for debugging
                logger.info(f"Dify upload response: {upload_response.text}")
                return upload_response.json()
        finally:
            # Clean up temporary file
            os.unlink(temp_file_path)

    except Exception as e:
        logger.error(f"Error uploading file to Dify: {str(e)}")
        if hasattr(e, 'response'):
            logger.error(f"Upload response content: {e.response.text}")
        return None

@app.task
def process_question(Body: str, From: str, media_items: Optional[List[Dict]] = None):
    """Process incoming WhatsApp message with optional media"""
    logger.info(f"Processing message - From: {From}, Media Items: {len(media_items) if media_items else 0}")

    try:
        if is_rate_limited(From):
            logger.info(f"Rate limit exceeded for {From}")
            send_message(From, "You have exceeded the message rate limit. Please try again later.")
            return

        dify_key = config("DIFY_KEY")
        base_url = get_dify_base_url()
        chat_url = f"{base_url}/chat-messages"

        # Format user identifier
        dify_user = From if From.startswith("whatsapp:") else f"whatsapp:{From.strip()}"

        # Get existing conversation
        conversation_id = None
        logger.info(f"Getting conversations from: {base_url}/conversations")
        conversations_response = requests.get(
            f"{base_url}/conversations",
            headers={'Authorization': f'Bearer {dify_key}'},
            params={'user': dify_user}
        )
        conversations_response.raise_for_status()
        conversations_data = conversations_response.json()

        if "data" in conversations_data:
            conversation_list = conversations_data.get("data")
            if conversation_list:
                conversation_id = conversation_list[0].get("id")

        # Process media if present
        uploaded_files = []
        if media_items:
            for item in media_items:
                media_content = download_media_from_twilio(item['url'])
                if media_content:
                    file_info = upload_file_to_dify(
                        media_content,
                        item['content_type'],
                        dify_user
                    )
                    if file_info:
                        uploaded_files.append({
                            'id': file_info['id'],
                            'type': 'image',
                            'name': file_info.get('name', 'image'),
                            'size': file_info.get('size', 0),
                            'mime_type': file_info.get('mime_type', item['content_type'])
                        })
                        logger.info(f"File uploaded to Dify: {file_info['id']}")

        # Prepare message parameters
        message_params = {
            'query': Body or "Please analyze this image",
            'user': dify_user,
            'inputs': {},
            'files': uploaded_files,
            'response_mode': "blocking"
        }

        if conversation_id:
            message_params['conversation_id'] = conversation_id

        # Send chat message
        logger.info(f"Sending chat message to: {chat_url}")
        logger.info(f"Message params: {message_params}")

        chat_response = requests.post(
            chat_url,
            headers={'Authorization': f'Bearer {dify_key}'},
            json=message_params
        )
        chat_response.raise_for_status()

        # Log response for debugging
        logger.info(f"Chat response: {chat_response.text}")

        result = chat_response.json().get("answer")

        if not result:
            raise ValueError("Empty response from Dify")

        # Send response back to user
        send_message(From, result)
        log_message(From, Body, result, "success")

    except Exception as e:
        logger.error(f"Error processing message: {str(e)}")
        if hasattr(e, 'response'):
            logger.error(f"Response content: {e.response.text}")
        log_message(From, Body, str(e), "error")
        error_msg = "Sorry, I encountered an error processing your message. Please try again later."
        send_message(From, error_msg)
```

## app\scheduler\__init__.py

- Characters: 0
- Tokens: 0

```python

```

## app\tasks\utils.py

- Characters: 4218
- Tokens: 978

```python
# utils.py
import logging
import redis
from twilio.rest import Client
from decouple import config
from app.db.models import MessageLog
from app.db.database import SessionLocal
from typing import Optional, List, Dict, Union

# Twilio configuration
account_sid = config('TWILIO_ACCOUNT_SID')
auth_token = config('TWILIO_AUTH_TOKEN')
client = Client(account_sid, auth_token)
twilio_number = config('TWILIO_NUMBER')

# Logging configuration
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('app_data/app.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

def log_message(phone_number: str, message: str, response: str, status: str):
    db = SessionLocal()
    try:
        log_entry = MessageLog(
            phone_number=phone_number,
            message=message,
            response=response,
            status=status
        )
        db.add(log_entry)
        db.commit()
    except Exception as e:
        logger.error(f"Error logging message: {e}")
        db.rollback()
    finally:
        db.close()

def send_message(
    to_number: str,
    body_text: Optional[str] = None,
    media_url: Optional[Union[str, List[str]]] = None
) -> Optional[str]:
    """
    Send a WhatsApp message with optional media

    Args:
        to_number: Destination phone number
        body_text: Optional text message
        media_url: Optional media URL or list of URLs

    Returns:
        Message SID if successful, None otherwise
    """
    try:
        # Validate at least one of body or media is present
        if not body_text and not media_url:
            logger.error("Both message body and media are empty")
            return None

        # Format WhatsApp number correctly
        if not to_number.startswith("whatsapp:"):
            to_number = f"whatsapp:{to_number.strip()}"
        else:
            parts = to_number.split(":")
            to_number = f"{parts[0]}:{parts[1].strip()}"

        # Prepare message parameters
        message_params = {
            'from_': f"whatsapp:{twilio_number.strip()}",
            'to': to_number
        }

        # Add body if present
        if body_text and body_text.strip():
            message_params['body'] = body_text

        # Add media if present
        if media_url:
            if isinstance(media_url, str):
                media_url = [media_url]
            message_params['media_url'] = media_url

        # Send message
        message = client.messages.create(**message_params)

        logger.info(f"Message sent to {to_number} - SID: {message.sid}")
        log_message(
            to_number,
            f"Body: {body_text}, Media: {media_url}",
            f"Message SID: {message.sid}",
            "success"
        )
        return message.sid

    except Exception as e:
        logger.error(f"Error sending message to {to_number}: {e}")
        log_message(to_number, body_text or "", str(e), "error")
        raise e

# Redis rate limiting
redis_client = redis.StrictRedis(host='redis', port=6379)
RATE_LIMIT = config('RATE_LIMIT', default=2, cast=int)
TIME_WINDOW = config('TIME_WINDOW', default=60, cast=int)

def is_rate_limited(phone_number: str) -> bool:
    """Check if a phone number has exceeded rate limits"""
    key = f"rate_limit:{phone_number}"
    current_count = redis_client.get(key)

    if current_count is None:
        redis_client.setex(key, TIME_WINDOW, 1)
        return False
    elif int(current_count) < RATE_LIMIT:
        redis_client.incr(key)
        return False
    else:
        log_message(phone_number, "", "Rate limit exceeded", "rate_limited")
        return True

def get_mime_type(file_extension: str) -> Optional[str]:
    """Get MIME type for common WhatsApp supported formats"""
    mime_types = {
        'jpg': 'image/jpeg',
        'jpeg': 'image/jpeg',
        'png': 'image/png',
        'webp': 'image/webp',
        'pdf': 'application/pdf',
        'mp3': 'audio/mpeg',
        'mp4': 'video/mp4',
        'ogg': 'audio/ogg',
        'amr': 'audio/amr',
        'vcf': 'text/x-vcard'
    }
    return mime_types.get(file_extension.lower())
```

## Statistics

- Total Files: 14
- Total Characters: 22320
- Total Tokens: 4982
