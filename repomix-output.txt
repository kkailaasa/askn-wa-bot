This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-07T16:48:35.625Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
__init__.py
.env.example
app/api/dependencies.py
app/api/routes.py
app/core/config.py
app/db/database.py
app/services/dify.py
app/services/load_balancer.py
app/services/twilio.py
docker-compose.yml
Dockerfile
entrypoint.sh
main.py
requirements.txt
Version_Control.md

================================================================
Repository Files
================================================================

================
File: __init__.py
================
#__init__.py

================
File: .env.example
================
# Application Settings
APP_NAME="E-Citizen WhatsApp Bot"
APP_VERSION="1.0.0"
PORT=8000

# Environment Settings
ENVIRONMENT=development
DEBUG=True

# Security
API_KEY=your_secure_api_key_here

# Redis Configuration
REDIS_HOST=redis
REDIS_PORT=6379
REDIS_MAX_CONNECTIONS=10
REDIS_SOCKET_TIMEOUT=5
REDIS_SOCKET_CONNECT_TIMEOUT=2
REDIS_MAX_RETRIES=3
#REDIS_URL=redis://redis:6379/0

# Twilio Settings
TWILIO_ACCOUNT_SID=your_twilio_account_sid_here
TWILIO_AUTH_TOKEN=your_twilio_auth_token_here
TWILIO_NUMBERS=TWILIO_NUMBER_1,TWILIO_NUMBER_2
TWILIO_MAX_CONNECTIONS=10

# Dify Settings
DIFY_KEY=your_dify_api_key_here
DIFY_URL=http://dify.url
DIFY_MAX_CONNECTIONS=10
DIFY_TIMEOUT=15

# Mattermost Settings
MATTERMOST_WEBHOOK_URL=your_mattermost_webhook_url

# WhatsApp Limits

LOAD_BALANCER_HIGH_THRESHOLD=0.7
LOAD_BALANCER_ALERT_THRESHOLD=0.9

================
File: app/api/dependencies.py
================
# app/api/dependencies.py

from fastapi import HTTPException, Request, Depends
from typing import Callable
import time
from app.core.config import settings
import structlog
from collections import defaultdict

logger = structlog.get_logger()

class RateLimiter:
    def __init__(self):
        self.requests = defaultdict(list)

    def is_rate_limited(self, key: str, limit: int, period: int) -> bool:
        now = time.time()

        # Remove old requests
        self.requests[key] = [req_time for req_time in self.requests[key]
                            if now - req_time < period]

        # Check if limit is exceeded
        if len(self.requests[key]) >= limit:
            return True

        # Add new request
        self.requests[key].append(now)
        return False

rate_limiter = RateLimiter()

def rate_limit(limit: int, period: int) -> Callable:
    async def rate_limit_dependency(request: Request):
        client_ip = request.headers.get("CF-Connecting-IP", request.client.host)

        if rate_limiter.is_rate_limited(client_ip, limit, period):
            logger.warning(
                "rate_limit_exceeded",
                ip=client_ip,
                endpoint=request.url.path
            )
            raise HTTPException(
                status_code=429,
                detail="Too many requests"
            )

        return True
    return rate_limit_dependency

async def verify_api_key(request: Request) -> bool:
    """Verify API key from headers"""
    api_key = request.headers.get('X-API-Key')

    if not api_key or api_key != settings.API_KEY:
        logger.warning(
            "invalid_api_key",
            ip=request.headers.get("CF-Connecting-IP", request.client.host)
        )
        raise HTTPException(
            status_code=403,
            detail="Invalid API key"
        )

    return True

================
File: app/api/routes.py
================
# app/api/routes.py

from fastapi import APIRouter, Depends, Request, Form, HTTPException
from sqlalchemy.orm import Session
import structlog
from datetime import datetime
from typing import Dict, Any

from app.core.config import settings
from app.db.database import get_db
from app.db.models import MessageLog, ErrorLog, RequestLog
from app.services.twilio import TwilioClient
from app.services.dify import DifyService
from app.services.load_balancer import LoadBalancer
from app.api.dependencies import rate_limit, verify_api_key

logger = structlog.get_logger()

router = APIRouter()
twilio_client = TwilioClient()
dify_service = DifyService()
load_balancer = LoadBalancer()

@router.get("/message")
async def redirect_to_wa(
    request: Request,
    db: Session = Depends(get_db),
    _=Depends(verify_api_key)
):
    """Redirect to least loaded WhatsApp number"""
    start_time = datetime.utcnow()

    try:
        # Extract CloudFlare headers
        cf_data = {
            "cf_ip": request.headers.get("CF-Connecting-IP"),
            "cf_country": request.headers.get("CF-IPCountry"),
            "cf_ray": request.headers.get("CF-RAY"),
            "user_agent": request.headers.get("User-Agent")
        }

        # Get least loaded number
        wa_number = await load_balancer.get_available_number()
        if not wa_number:
            raise HTTPException(status_code=503, detail="No available WhatsApp numbers")

        # Format WhatsApp URL
        wa_url = f"https://wa.me/{wa_number.replace('whatsapp:', '')}"

        # Log request
        request_log = RequestLog(
            twilio_number=wa_number,
            client_ip=cf_data["cf_ip"],
            cloudflare_data=cf_data,
            request_data={"redirect_url": wa_url},
            response_status=302,
            processing_time=(datetime.utcnow() - start_time).total_seconds()
        )
        db.add(request_log)
        db.commit()

        # Return redirect response
        return RedirectResponse(
            url=wa_url,
            status_code=302
        )

    except Exception as e:
        # Log error
        error_log = ErrorLog(
            error_type=type(e).__name__,
            error_message=str(e),
            metadata={
                "cloudflare_data": cf_data if 'cf_data' in locals() else None
            }
        )
        db.add(error_log)

        if 'request_log' in locals():
            request_log.response_status = 500
            request_log.processing_time = (datetime.utcnow() - start_time).total_seconds()

        db.commit()

        logger.error(
            "redirect_error",
            error=str(e),
            error_type=type(e).__name__
        )
        raise HTTPException(status_code=500, detail="Internal server error")

@router.post("/webhook")
async def handle_message(
    request: Request,
    Body: str = Form(...),
    From: str = Form(...),
    To: str = Form(None),
    db: Session = Depends(get_db),
    _=Depends(verify_api_key)
):
    """Handle incoming WhatsApp messages"""
    start_time = datetime.utcnow()

    try:
        # Extract CloudFlare headers
        cf_data = {
            "cf_ip": request.headers.get("CF-Connecting-IP"),
            "cf_country": request.headers.get("CF-IPCountry"),
            "cf_ray": request.headers.get("CF-RAY"),
            "user_agent": request.headers.get("User-Agent")
        }

        # Log incoming request
        request_log = RequestLog(
            twilio_number=To,
            client_ip=cf_data["cf_ip"],
            cloudflare_data=cf_data,
            request_data={"body": Body, "from": From, "to": To}
        )
        db.add(request_log)

        # Get or create conversation
        conversation_id = await dify_service.get_conversation_id(From)

        # Get response from Dify
        dify_response = await dify_service.send_message(
            user=From,
            message=Body,
            conversation_id=conversation_id
        )

        # Get available Twilio number for response
        response_number = await load_balancer.get_available_number()
        if not response_number:
            raise HTTPException(status_code=503, detail="No available WhatsApp numbers")

        # Send response via Twilio
        twilio_response = await twilio_client.send_message(
            from_=response_number,
            to=From,
            body=dify_response["message"]
        )

        # Log successful message
        message_log = MessageLog(
            from_number=From,
            message=Body,
            response=dify_response["message"],
            conversation_id=conversation_id
        )
        db.add(message_log)

        # Update request log with response info
        end_time = datetime.utcnow()
        request_log.response_status = 200
        request_log.processing_time = (end_time - start_time).total_seconds()

        db.commit()

        return {"status": "success", "message_sid": twilio_response["sid"]}

    except Exception as e:
        # Log error
        error_log = ErrorLog(
            error_type=type(e).__name__,
            error_message=str(e),
            metadata={
                "from_number": From,
                "conversation_id": conversation_id if 'conversation_id' in locals() else None
            }
        )
        db.add(error_log)

        # Update request log with error info
        if 'request_log' in locals():
            request_log.response_status = 500
            request_log.processing_time = (datetime.utcnow() - start_time).total_seconds()

        db.commit()

        logger.error(
            "webhook_error",
            error=str(e),
            error_type=type(e).__name__
        )
        raise HTTPException(status_code=500, detail="Internal server error")

@router.get("/health")
async def health_check():
    """Health check endpoint with service status"""
    dify_health = await dify_service.health_check()
    load_stats = load_balancer.get_all_stats()

    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(),
        "services": {
            "dify": "healthy" if dify_health else "unhealthy",
            "twilio_numbers": load_stats
        }
    }

@router.get("/stats/load")
async def get_load_stats(
    _=Depends(rate_limit(
        limit=settings.RATE_LIMIT_LOAD_STATS_LIMIT,
        period=settings.RATE_LIMIT_LOAD_STATS_PERIOD
    ))
):
    """Get current load statistics for all WhatsApp numbers"""
    stats = load_balancer.get_all_stats()

    return {
        "stats": stats,
        "thresholds": {
            "high_load": settings.LOAD_BALANCER_HIGH_THRESHOLD * 100,
            "alert": settings.LOAD_BALANCER_ALERT_THRESHOLD * 100
        },
        "window_size": settings.LOAD_BALANCER_STATS_WINDOW
    }

@router.get("/messages/{phone}")
async def get_message_history(
    phone: str,
    db: Session = Depends(get_db),
    _=Depends(verify_api_key)
):
    """Get message history for a phone number"""
    messages = db.query(MessageLog).filter(
        MessageLog.from_number == phone
    ).order_by(MessageLog.timestamp.desc()).limit(100).all()

    return {
        "phone": phone,
        "messages": [
            {
                "timestamp": msg.timestamp.isoformat(),
                "message": msg.message,
                "response": msg.response,
                "conversation_id": msg.conversation_id
            }
            for msg in messages
        ]
    }

================
File: app/core/config.py
================
# app/core/config.py
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    APP_NAME: str = "WhatsApp Bot"
    DEBUG: bool = False
    API_KEY: str

    # Twilio Settings
    TWILIO_ACCOUNT_SID: str
    TWILIO_AUTH_TOKEN: str
    TWILIO_NUMBERS: list[str]

    # Dify Settings
    DIFY_KEY: str
    DIFY_URL: str

    # Load Balancer Settings
    LOAD_BALANCER_HIGH_THRESHOLD: float = 0.7
    LOAD_BALANCER_ALERT_THRESHOLD: float = 0.9

    # Mattermost Settings
    MATTERMOST_WEBHOOK_URL: str

    class Config:
        env_file = ".env"

settings = Settings()

================
File: app/db/database.py
================
# app/db/database.py

from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
import os

# Create data directory if it doesn't exist
os.makedirs('data', exist_ok=True)

SQLALCHEMY_DATABASE_URL = "sqlite:///data/app.db"

engine = create_engine(
    SQLALCHEMY_DATABASE_URL,
    connect_args={"check_same_thread": False}  # Needed for SQLite
)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

================
File: app/services/dify.py
================
# app/services/dify.py
from dify_client import ChatClient
import structlog
import re
from typing import Optional, Dict, Any
from datetime import datetime
from fastapi import HTTPException
from app.core.config import settings
from utils.redis_helpers import AsyncRedisLock, cache

logger = structlog.get_logger(__name__)

class DifyError(Exception):
    def __init__(self, message: str, error_code: str):
        self.message = message
        self.error_code = error_code
        super().__init__(self.message)

class DifyService:
    def __init__(self):
        try:
            self.chat_client = ChatClient(settings.DIFY_KEY)
            self.chat_client.base_url = settings.DIFY_URL
            self.cache_prefix = "dify_chat:"

            logger.info(
                "dify_service_initialized",
                dify_url=settings.DIFY_URL,
                max_connections=settings.DIFY_MAX_CONNECTIONS
            )
        except Exception as e:
            logger.error(
                "dify_service_initialization_failed",
                error=str(e),
                error_type=type(e).__name__
            )
            raise

    def _sanitize_message(self, message: str) -> str:
        """Sanitize message content with enhanced validation"""
        if not message:
            return ""

        # Remove control characters and Unicode
        sanitized = "".join(char for char in message if char.isprintable())

        # Additional security checks
        sanitized = re.sub(r'[^\w\s\-.,?!@#$%^&*()[\]{}|\\/\'\":;~`<>+=]', '', sanitized)

        # Enforce maximum length
        max_length = 4096
        if len(sanitized) > max_length:
            logger.warning(
                "message_truncated",
                original_length=len(message),
                truncated_length=max_length
            )
            return sanitized[:max_length]

        return sanitized

    def _sanitize_phone(self, phone: str) -> str:
        """Sanitize phone number with enhanced validation"""
        if not phone:
            raise DifyError("Phone number cannot be empty", "INVALID_PHONE")

        # Remove all non-digit characters except +
        cleaned = re.sub(r'[^\d+]', '', phone)

        # Validate format
        if not re.match(r'^\+?\d{10,15}$', cleaned):
            raise DifyError("Invalid phone number format", "INVALID_PHONE")

        return cleaned

    async def format_phone_number(self, phone_number: str) -> str:
        """Format phone number for Dify chat with validation"""
        logger.debug("formatting_phone_number", phone_number=phone_number)

        try:
            # Remove whatsapp: prefix and whitespace
            phone_number = phone_number.replace("whatsapp:", "").strip()

            # Ensure it starts with +
            if not phone_number.startswith('+'):
                phone_number = f"+{phone_number}"

            # Validate final format
            sanitized_phone = self._sanitize_phone(phone_number)

            logger.debug("phone_number_formatted", result=sanitized_phone)
            return sanitized_phone

        except Exception as e:
            logger.error(
                "phone_formatting_failed",
                phone_number=phone_number,
                error=str(e)
            )
            raise

    async def get_conversation_id(self, user: str) -> Optional[str]:
        """Get conversation ID for a user with caching and error handling"""
        cache_key = f"{self.cache_prefix}conv:{user}"

        try:
            # Check cache first
            cached_id = await cache.get(cache_key)
            if cached_id:
                return cached_id

            logger.debug("getting_conversations", user=user)
            formatted_user = await self.format_phone_number(user)

            # Use distributed lock to prevent concurrent requests
            async with AsyncRedisLock(f"dify_conv:{formatted_user}"):
                conversations = await self.chat_client.get_conversations(user=formatted_user)

                if conversations:
                    conv_id = conversations[0].get("id")
                    # Cache the result
                    await cache.set(cache_key, conv_id, expiry=3600)
                    return conv_id

            return None

        except Exception as e:
            logger.error(
                "get_conversation_failed",
                user=user,
                error=str(e),
                error_type=type(e).__name__
            )
            return None

    async def send_message(
        self,
        user: str,
        message: str,
        conversation_id: Optional[str] = None,
        auth_context: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        try:
            # Input validation and sanitization
            if not message:
                raise DifyError("Message cannot be empty", "INVALID_MESSAGE")

            sanitized_message = self._sanitize_message(message)
            formatted_phone = await self.format_phone_number(user)

            # Prepare request payload
            response = await self.chat_client.create_chat_message(
                query=sanitized_message,
                user=formatted_phone,
                conversation_id=conversation_id,
                inputs=auth_context or {},
                response_mode="blocking"
            )

            # Handle auth verification needs
            if response.get("needs_auth_verification"):
                return {
                    "needs_auth_verification": True,
                    "required_operation": response.get("required_operation"),
                    "operation_data": response.get("operation_data", {}),
                    "message": response.get("message", "Additional verification needed")
                }

            return {
                "message": response.get("answer", "I couldn't process your message."),
                "conversation_id": response.get("conversation_id"),
                "timestamp": datetime.utcnow().isoformat(),
                "success": True
            }

        except DifyError as e:
            logger.error("dify_validation_error", error=str(e), code=e.error_code)
            raise HTTPException(status_code=400, detail={"message": str(e), "code": e.error_code})
        except Exception as e:
            logger.error(
                "send_message_failed",
                user=user,
                error=str(e),
                error_type=type(e).__name__
            )
            raise HTTPException(status_code=500, detail="Failed to process message")

    async def health_check(self) -> bool:
        try:
            return await self.chat_client.health_check()
        except:
            return False

================
File: app/services/load_balancer.py
================
# app/services/load_balancer.py

from dataclasses import dataclass
import time
import aiohttp
import structlog
from typing import Dict, List, Optional
import os
from collections import defaultdict
from app.core.config import settings

logger = structlog.get_logger()

@dataclass
class NumberStats:
    """Track stats for a WhatsApp number"""
    requests: int = 0
    last_reset: float = time.time()
    window_size: int = 60  # 1 minute rolling window

    def add_request(self) -> None:
        """Add a request and reset if window expired"""
        current_time = time.time()
        # Reset counter if window expired
        if current_time - self.last_reset >= self.window_size:
            self.requests = 0
            self.last_reset = current_time
        self.requests += 1

    def get_load(self) -> float:
        """Get current load as percentage of max capacity"""
        current_time = time.time()
        # Reset if window expired
        if current_time - self.last_reset >= self.window_size:
            self.requests = 0
            self.last_reset = current_time
        return self.requests / settings.MAX_MESSAGES_PER_SECOND  # Using 80 msgs/sec as max

    def get_stats(self) -> Dict:
        """Get current stats for the number"""
        return {
            "requests": self.requests,
            "load_percentage": self.get_load() * 100,
            "window_start": self.last_reset,
            "window_end": self.last_reset + self.window_size
        }

class LoadBalancer:
    def __init__(self):
        """Initialize load balancer with configured Twilio numbers"""
        self.numbers = settings.TWILIO_NUMBERS
        if not self.numbers:
            raise ValueError("No Twilio numbers configured")

        # Initialize stats for each number
        self.stats: Dict[str, NumberStats] = {
            num: NumberStats() for num in self.numbers
        }

        # Load balancer thresholds
        self.high_threshold = settings.LOAD_BALANCER_HIGH_THRESHOLD  # 70%
        self.alert_threshold = settings.LOAD_BALANCER_ALERT_THRESHOLD  # 90%
        self.stats_window = settings.LOAD_BALANCER_STATS_WINDOW  # 60 seconds

        logger.info(
            "load_balancer_initialized",
            number_count=len(self.numbers),
            high_threshold=self.high_threshold,
            alert_threshold=self.alert_threshold
        )

    async def send_mattermost_alert(self, number: str, load: float) -> None:
        """Send alert to Mattermost when load exceeds threshold"""
        if not settings.MATTERMOST_WEBHOOK_URL:
            return

        message = {
            "text": (f"🚨 High Load Alert!\n"
                    f"WhatsApp number: {number}\n"
                    f"Current load: {load*100:.1f}%\n"
                    f"Time: {time.strftime('%Y-%m-%d %H:%M:%S')}")
        }

        async with aiohttp.ClientSession() as session:
            try:
                async with session.post(settings.MATTERMOST_WEBHOOK_URL, json=message) as response:
                    if response.status != 200:
                        logger.error("mattermost_alert_failed",
                                   status=response.status,
                                   number=number,
                                   load=load)
            except Exception as e:
                logger.error("mattermost_alert_error", error=str(e))

    async def get_available_number(self) -> Optional[str]:
        """Get the best available number based on current load"""
        min_load = float('inf')
        selected_number = None

        for number, stats in self.stats.items():
            current_load = stats.get_load()

            # Send alert if load is too high
            if current_load >= self.alert_threshold:
                await self.send_mattermost_alert(number, current_load)

            # Skip numbers above high threshold unless all numbers are high
            if current_load >= self.high_threshold and min_load < self.high_threshold:
                continue

            if current_load < min_load:
                min_load = current_load
                selected_number = number

        if selected_number:
            # Record this request
            self.stats[selected_number].add_request()

            logger.info(
                "number_selected",
                number=selected_number,
                current_load=min_load*100
            )

        return selected_number

    def get_all_stats(self) -> Dict[str, Dict]:
        """Get current stats for all numbers"""
        return {
            number: stats.get_stats()
            for number, stats in self.stats.items()
        }

================
File: app/services/twilio.py
================
# app/services/twilio.py

from twilio.rest import Client
from twilio.request_validator import RequestValidator
from typing import Optional
import structlog
from app.core.config import settings
from app.services.load_balancer import LoadBalancer

logger = structlog.get_logger()

class TwilioClient:
    def __init__(self):
        self.client = Client(settings.TWILIO_ACCOUNT_SID, settings.TWILIO_AUTH_TOKEN)
        self.validator = RequestValidator(settings.TWILIO_AUTH_TOKEN)
        self.numbers = settings.TWILIO_NUMBERS
        self.load_balancer = LoadBalancer(self.numbers)

    async def send_message(self, to: str, body: str) -> Optional[dict]:
        try:
            from_number = await self.load_balancer.get_available_number()
            if not from_number:
                raise Exception("No available WhatsApp numbers")

            # Format numbers for WhatsApp
            to_number = f"whatsapp:{to}" if not to.startswith("whatsapp:") else to
            from_number = f"whatsapp:{from_number}" if not from_number.startswith("whatsapp:") else from_number

            message = self.client.messages.create(
                from_=from_number,
                body=body,
                to=to_number
            )

            return {
                "sid": message.sid,
                "status": message.status,
                "from": message.from_
            }

        except Exception as e:
            logger.error("twilio_send_error", error=str(e), to=to)
            return None

    def verify_request(self, url: str, params: dict, signature: str) -> bool:
        """Verify Twilio request signature"""
        return self.validator.validate(
            url,
            params,
            signature
        )

================
File: docker-compose.yml
================
version: '3.8'
services:
  bot:
    build: .
    ports:
      - "7262:8000"
    depends_on:
      - redis
      - db
    environment:
      - SERVICE_NAME=web
      - PYTHONPATH=/app
    env_file:
      - .env
    extra_hosts:
      - "host.docker.internal:host-gateway"
    networks:
      - default

  celery_worker:
    build: .
    command: celery -A tasks.celery_tasks worker -Q high,default,low --loglevel=info
    depends_on:
      - redis
      - db
    environment:
      - SERVICE_NAME=celery_worker
      - PYTHONPATH=/app
      - C_FORCE_ROOT=true
    env_file:
      - .env
    extra_hosts:
      - "host.docker.internal:host-gateway"
    networks:
      - default

  celery_beat:
    build: .
    command: celery -A tasks.celery_tasks beat --loglevel=info
    depends_on:
      - redis
      - db
    environment:
      - SERVICE_NAME=celery_beat
      - PYTHONPATH=/app
      - C_FORCE_ROOT=true
    env_file:
      - .env
    extra_hosts:
      - "host.docker.internal:host-gateway"
    networks:
      - default

  redis:
    image: "redis:alpine"
    volumes:
      - ./data/redis_data:/data
    command: redis-server --appendonly yes
    networks:
      - default

  db:
    image: postgres:15-alpine
    volumes:
      - ./data/postgres_data:/var/lib/postgresql/data
    env_file:
      - .env
    networks:
      - default

networks:
  default:
    driver: bridge

volumes:
  redis_data:
  postgres_data:

================
File: Dockerfile
================
FROM python:3.11-slim

# Install gosu, postgres client and other dependencies
RUN set -eux; \
    apt-get update; \
    apt-get install -y gosu postgresql-client ; \
    rm -rf /var/lib/apt/lists/*; \
    gosu nobody true

# Set the working directory
WORKDIR /app

# Copy requirements first for better caching
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Create required directories
RUN mkdir -p logs temp templates

# Copy entrypoint script first and make it executable
COPY entrypoint.sh /usr/local/bin/
RUN chmod +x /usr/local/bin/entrypoint.sh

# Copy the rest of the application
COPY . .

# Create a non-root user and set specific directory permissions
RUN adduser --disabled-password --gecos '' appuser \
    && chown -R appuser:appuser /app/logs /app/temp /app/templates \
    && chown appuser:appuser /app

# Set environment variables
ENV PYTHONPATH=/app
ENV PYTHONUNBUFFERED=1

ENTRYPOINT ["/usr/local/bin/entrypoint.sh"]

# Default command (will be overridden by docker-compose for celery services)
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]

================
File: entrypoint.sh
================
#!/bin/bash
set -e

# Wait for database to be ready
until PGPASSWORD=$POSTGRES_PASSWORD psql -h "db" -U "postgres" -c '\q'; do
    >&2 echo "Postgres is unavailable - sleeping"
    sleep 1
done

>&2 echo "Postgres is up - executing command"

# Create required directories if they don't exist
mkdir -p logs temp templates

# Set proper permissions
chown -R appuser:appuser /app/logs /app/temp /app/templates

# Only run migrations from the web service
if [ "$SERVICE_NAME" = "web" ]; then
    echo "Running migrations..."
    gosu appuser alembic upgrade head
fi

# Run the command as appuser
exec gosu appuser "$@"

================
File: main.py
================
# main.py

import structlog
import logging
import sys
import json
import time
import os
import httpx
import traceback

from pathlib import Path
from fastapi import FastAPI, Form, Request, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
from typing import Optional, Dict, Any
from datetime import datetime
from sqlalchemy import create_engine, Column, Integer, String, DateTime, JSON, Text
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

# Create data directory if it doesn't exist
Path("data").mkdir(exist_ok=True)

# Database setup
Base = declarative_base()
engine = create_engine('sqlite:///data/app.db')
SessionLocal = sessionmaker(bind=engine)

class ErrorLog(Base):
    __tablename__ = "error_logs"

    id = Column(Integer, primary_key=True)
    timestamp = Column(DateTime, default=datetime.utcnow)
    error_type = Column(String(100))
    error_message = Column(Text)
    stack_trace = Column(Text)
    metadata = Column(JSON)

class MessageLog(Base):
    __tablename__ = "message_logs"

    id = Column(Integer, primary_key=True)
    timestamp = Column(DateTime, default=datetime.utcnow)
    from_number = Column(String(50))
    message = Column(Text)
    response = Column(Text)
    conversation_id = Column(String(100))

# Create tables
Base.metadata.create_all(engine)
import os
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Initialize logging
logger = structlog.get_logger()

# Initialize FastAPI app
app = FastAPI(title="Twilio-Dify Integration")

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class DifyClient:
    def __init__(self):
        self.api_key = os.getenv('DIFY_API_KEY')
        self.base_url = os.getenv('DIFY_URL')

    async def get_conversation_id(self, user: str) -> Optional[str]:
        """Get or create conversation ID for user"""
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    f"{self.base_url}/conversations",
                    headers={"Authorization": f"Bearer {self.api_key}"},
                    params={"user": user}
                )
                response.raise_for_status()
                data = response.json()
                conversations = data.get("data", [])
                return conversations[0]["id"] if conversations else None
        except Exception as e:
            logger.error("dify_get_conversation_error", error=str(e))
            return None

    async def send_message(
        self,
        user: str,
        message: str,
        conversation_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """Send message to Dify and get response"""
        try:
            payload = {
                "inputs": {},
                "query": message,
                "user": user,
                "response_mode": "blocking",
                "conversation_id": conversation_id
            }

            async with httpx.AsyncClient() as client:
                response = await client.post(
                    f"{self.base_url}/chat/completions",
                    headers={"Authorization": f"Bearer {self.api_key}"},
                    json=payload
                )
                response.raise_for_status()
                return response.json()
        except Exception as e:
            logger.error("dify_send_message_error", error=str(e))
            raise HTTPException(status_code=500, detail="Failed to process message")

class TwilioClient:
    def __init__(self):
        self.account_sid = os.getenv('TWILIO_ACCOUNT_SID')
        self.auth_token = os.getenv('TWILIO_AUTH_TOKEN')
        self.numbers = os.getenv('TWILIO_NUMBERS', '').split(',')
        self.load_balancer = LoadBalancer(self.numbers)

    async def send_message(self, to: str, body: str, db: SessionLocal):
        """Send WhatsApp message via Twilio"""
        try:
            # Get available number from load balancer
            from_number = await self.load_balancer.get_available_number()

            # Format numbers
            to_number = f"whatsapp:{to}" if not to.startswith("whatsapp:") else to
            from_number = f"whatsapp:{from_number}" if not from_number.startswith("whatsapp:") else from_number

            async with httpx.AsyncClient() as client:
                response = await client.post(
                    f"https://api.twilio.com/2010-04-01/Accounts/{self.account_sid}/Messages.json",
                    auth=(self.account_sid, self.auth_token),
                    data={
                        "From": from_number,
                        "To": to_number,
                        "Body": body
                    }
                )
                response.raise_for_status()
                return response.json()
        except Exception as e:
            logger.error("twilio_send_error", error=str(e))
            raise HTTPException(status_code=500, detail="Failed to send message")

# Initialize clients
dify_client = DifyClient()
twilio_client = TwilioClient()

async def verify_twilio_request(request: Request):
    """Very basic verification - enhance based on your security needs"""
    api_key = request.headers.get('X-API-Key')
    if not api_key or api_key != os.getenv('API_KEY'):
        raise HTTPException(status_code=403, detail="Invalid API key")
    return True

@app.post("/webhook")
async def handle_message(
    request: Request,
    Body: str = Form(...),
    From: str = Form(...),
    _: bool = Depends(verify_twilio_request)
):
    """Handle incoming WhatsApp messages"""
    db = SessionLocal()
    try:
        # Get or create conversation
        conversation_id = await dify_client.get_conversation_id(From)

        # Get response from Dify
        dify_response = await dify_client.send_message(
            user=From,
            message=Body,
            conversation_id=conversation_id
        )

        # Extract response text
        response_text = dify_response.get('answer', 'Sorry, I could not process your message.')

        # Send response back via Twilio
        await twilio_client.send_message(From, response_text)

        # Log successful message
        message_log = MessageLog(
            from_number=From,
            message=Body,
            response=response_text,
            conversation_id=conversation_id
        )
        db.add(message_log)
        db.commit()

        return {"status": "success"}

    except Exception as e:
        # Log error
        error_log = ErrorLog(
            error_type=type(e).__name__,
            error_message=str(e),
            stack_trace=traceback.format_exc(),
            metadata={
                "from_number": From,
                "conversation_id": conversation_id if 'conversation_id' in locals() else None
            }
        )
        db.add(error_log)
        db.commit()

        logger.error("webhook_error", error=str(e))
        raise HTTPException(status_code=500, detail="Internal server error")
    finally:
        db.close()

@app.get("/health")
async def health_check():
    """Basic health check endpoint"""
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat()
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)

================
File: requirements.txt
================
fastapi==0.104.1
uvicorn==0.24.0
python-multipart==0.0.6
dify-client
twilio==8.10.0
httpx==0.25.1
python-dotenv==1.0.0
structlog==23.2.0
pydantic-settings==2.1.0
typing-extensions==4.8.0

================
File: Version_Control.md
================
# Version Control Log

This document tracks the version history for the project, including the version number, release date, summary of changes, and contributors.

## Version History

---

### [v0.1.0] - 2024-10-20
##### Summary of Changes:
- Completed Basic Framework of the Application.
- Ingteration with NGPT Backend
- Basic API setup with FastAPI.
- Added `/check_phone`, `/check_email`, `/create_account`, `/send_email_otp`, and `/verify_email` `message` endpoints.
- Integrated with SendGrid for email OTPs.
- Configured Twilio for WhatsApp Interactions.
- Using Redis for caching responses from Keycloak

##### Contributors:
- **KAILASA Kenya** 

---

## Further Functionalities to be Completed for Release:

- Insert User Info into E-Citizen DB.
- Generate Ecitizen Number *&* ID Card.
- Enable Security Policy for `message` route to accept Requests only from `X-Twilio-Signature header` or `X-API-Key`
- Set `UPDATE_PASSWORD` as the only Required Action, remove `UPDATE_PHONE_NUMBER`
